{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"xodex","text":"<p>xodex is a lightweight, extensible game engine framework built on top of Pygame. It provides a small, focused set of tools for managing game projects, defining scenes, and composing objects with clearly separated responsibilities (drawing, logic updates, and event handling).</p>"},{"location":"#highlights","title":"Highlights","text":"<ul> <li>Minimal, composable object model (Drawable, Logical, Eventful)</li> <li>Scene lifecycle and object manager for simple game structure</li> <li>Management CLI for scaffolding and running projects</li> </ul>"},{"location":"#quick-installation","title":"Quick installation","text":"<p>Install from PyPI:</p> <pre><code>pip install xodex\n</code></pre>"},{"location":"#learn-more","title":"Learn more","text":"<p>See the Getting started guide for installation, first steps, and examples, or go to the Project for common workflows and quick commands.</p>"},{"location":"contributing/","title":"Contributing to xodex","text":"<p>Thank you for considering contributing to xodex. This page gives a short on-ramp to help you get started. See the repository README for full project policies and the code of conduct.</p> <p>How to contribute</p> <ol> <li>Fork the repository and create a feature branch.</li> <li>Run the test suite (if available) and keep changes small and focused.</li> <li>Open a pull request with a clear description and motivation.</li> </ol> <p>Local development</p> <p>Install development requirements and run tests locally. Example:</p> <pre><code>python -m venv .venv\nsource .venv/bin/activate\npip install -r requirements.txt\n# run the tests\npytest -q\n</code></pre> <p>Coding guidelines</p> <ul> <li>Keep public APIs stable and documented in the <code>docs/</code> folder.</li> <li>Add tests for new features and bug fixes where practical.</li> <li>Follow repository style (flake8/black where configured).</li> </ul> <p>Reporting issues</p> <p>Open an issue on GitHub with a minimal reproduction and the environment you used (OS, Python version, Pygame version).</p> <p>Thank you!</p>"},{"location":"project/","title":"Working on projects","text":"<p>xodex projects follow a small, opinionated layout so the engine can find scenes, objects, and configuration consistently. The project scaffold includes the code and the management scripts you need to run, build, and test your game.</p>"},{"location":"project/#creating-a-new-project","title":"Creating a new project","text":"<p>Scaffold a new project using the CLI:</p> <pre><code>xodex init hello-world\ncd hello-world\n</code></pre> <p>Or initialize the current folder:</p> <pre><code>mkdir hello-world\ncd hello-world\nxodex init\n</code></pre> <p>After scaffolding you will typically see:</p> <pre><code>.\n\u251c\u2500\u2500 project\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __main__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 objects.py      # register game objects and helper factories\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 scenes.py       # scene classes for game screens\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 settings.py     # project-specific configuration\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 manage.py           # convenience script to run the project's commands\n\u2514\u2500\u2500 requirements.txt\n</code></pre> <p>Try the built-in example (scaffolded <code>main</code> or <code>__main__</code>):</p> <pre><code>xodex run\n# or\npython -m project\n</code></pre>"},{"location":"project/#key-project-files","title":"Key project files","text":"<ul> <li><code>project/settings.py</code> \u2014 Central configuration (window size, FPS, title, assets).</li> <li><code>project/scenes.py</code> \u2014 Define scenes that inherit from <code>BaseScene</code>.</li> <li><code>project/objects.py</code> \u2014 Create concrete objects (sprites, UI elements) using <code>DrawableObject</code>, <code>LogicalObject</code>, or <code>EventfulObject</code>.</li> <li><code>manage.py</code> \u2014 Thin wrapper to call the management utility (convenience for development).</li> </ul> <p>Example <code>settings.py</code> snippet:</p> <pre><code># Window &amp; Display\nFPS = 60\nWIDTH = 720\nHEIGHT = 560\nWINDOW_SIZE = (WIDTH, HEIGHT)\nTITLE = \"Hello Xodex\"\nVERSION = \"0.1.0\"\nFULLSCREEN = False\nICON_PATH = None\n</code></pre>"},{"location":"project/#working-flow","title":"Working flow","text":"<ol> <li>Scaffold with <code>xodex init</code>.</li> <li>Implement scenes in <code>project/scenes.py</code> and objects in <code>project/objects.py</code>.</li> <li>Run with <code>xodex run</code> during development.</li> <li>When ready, use <code>xodex build</code> (or your own packaging workflow) to create a distributable.</li> </ol> <p>For more detail on the API and object model see the Documentation.</p>"},{"location":"release-notes/","title":"Release Notes","text":"<p>This page will list notable changes and releases for xodex. For now, see the GitHub releases page for a full changelog and tagged releases.</p> <p>Key notes</p> <ul> <li>0.1.0 \u2014 Initial public release (placeholder)</li> </ul> <p>See the project's GitHub Releases for detailed change logs and download artifacts: https://github.com/djoezeke/xodex/releases</p>"},{"location":"sponsorship/","title":"Sponsorship","text":"<p>Sponsorship</p> <p>Support xodex development by becoming a sponsor. Sponsorship helps pay for hosting, development time, and community support. Please contact the project owner via GitHub for sponsorship details.</p> <p>Links</p> <ul> <li>GitHub: https://github.com/djoezeke</li> <li>Donate or sponsor: https://github.com/sponsors/djoezeke</li> </ul>"},{"location":"api/","title":"Documentation","text":"<p>This section summarizes the most commonly extended classes in xodex and how to use them in your project.</p> <ul> <li>Objects: <code>DrawableObject</code>, <code>LogicalObject</code>, <code>EventfulObject</code> and helpers (see <code>object.md</code>).</li> <li>Scenes: <code>BaseScene</code> and lifecycle methods (see <code>scene.md</code>).</li> </ul> <p>Where possible the docs include short code examples and the expected inputs/outputs for each public method.</p>"},{"location":"api/object/","title":"Object","text":"<p>xodex provides a small object system optimized for games. The core types are:</p> <ul> <li><code>DrawableObject</code> \u2014 implement <code>perform_draw(self, surface, *args, **kwargs)</code> to render.</li> <li><code>LogicalObject</code> \u2014 implement <code>perform_update(self, deltatime, *args, **kwargs)</code> to update logic.</li> <li><code>EventfulObject</code> \u2014 implement <code>handle_event(self, event, *args, **kwargs)</code> to react to events.</li> </ul> <p>All classes provide hooks and helpers:</p> <p>Contract / method summary</p> <ul> <li> <p>DrawableObject.perform_draw(surface, *args, **kwargs) -&gt; None</p> </li> <li> <p>surface: pygame.Surface to draw on</p> </li> <li> <p>Should not return a value; draw directly to the surface.</p> </li> <li> <p>DrawableObject.before_draw() -&gt; None</p> </li> <li>DrawableObject.after_draw() -&gt; None</li> <li> <p>DrawableObject.set_visible(visible: bool) -&gt; None</p> </li> <li> <p>LogicalObject.perform_update(deltatime: float, *args, **kwargs) -&gt; None</p> </li> <li> <p>deltatime: float seconds since last update.</p> </li> <li> <p>LogicalObject.before_update() -&gt; None</p> </li> <li> <p>LogicalObject.after_update() -&gt; None</p> </li> <li> <p>EventfulObject.handle_event(event: pygame.Event, *args, **kwargs) -&gt; None</p> </li> </ul> <p>Helpers</p> <ul> <li><code>make_xodex_object(cls=None, base_classes=(), register=False, name=None, method_map=None, hooks=None, **kwargs)</code></li> <li>Adapts your class to Xodex object bases. Useful when migrating plain classes.</li> <li>Example:</li> </ul> <pre><code>from xodex.object.base import make_xodex_object, DrawableObject\n\n@make_xodex_object(base_classes=(DrawableObject,))\nclass MyLegacySprite:\n    def draw(self, surface):\n        # user's draw method will be renamed to perform_draw\n        pass\n</code></pre> <p>Edge cases</p> <ul> <li>If a required method is missing for the chosen base classes, <code>make_xodex_object</code> will raise <code>TypeError</code>.</li> <li>The adapt function can optionally register the new class with the global ObjectsManager if <code>register=True</code> (project-dependent).</li> </ul>"},{"location":"api/scene/","title":"Scene","text":"<p><code>BaseScene</code> is the recommended base class for creating game screens and levels. It handles common tasks: object lifecycle, drawing, updating, event dispatch, and scene management.</p> <p>Key methods and properties</p> <ul> <li><code>__init__(self, *args, **kwargs)</code> \u2014 initializes screen size, objects manager, and sounds.</li> <li><code>elapsed</code> (property) -&gt; float \u2014 seconds since the scene started.</li> <li><code>screen</code> (property) -&gt; pygame.Surface \u2014 the scene's surface.</li> <li><code>objects</code> (property) -&gt; Objects \u2014 scene-local object collection.</li> <li><code>setup()</code> / <code>async_setup()</code> \u2014 (re)generate scene objects by calling <code>_generate_objects_</code>.</li> <li><code>draw_scene(*args, **kwargs)</code> -&gt; pygame.Surface \u2014 draws all registered objects and returns the surface.</li> <li><code>update_scene(deltatime: float, *args, **kwargs)</code> \u2014 updates all objects (skips if paused).</li> <li><code>handle_scene(event: pygame.Event, *args, **kwargs)</code> \u2014 handles a single event; recognizes <code>VIDEORESIZE</code> to resize.</li> <li><code>add_event(event)</code> / <code>dispatch_events()</code> \u2014 queue and dispatch events.</li> <li><code>pause()</code> / <code>resume()</code> / <code>toggle_pause()</code> \u2014 control update/event flow.</li> <li><code>filter_objects(predicate=None, obj_type=None)</code> -&gt; list \u2014 helper to query scene objects.</li> <li><code>snapshot()</code> -&gt; pygame.Surface \u2014 returns a copy of the scene surface.</li> <li><code>export_image(filename)</code> \u2014 saves the current scene surface to a file.</li> </ul> <p>Implementing a scene</p> <p>The required method to implement is <code>_generate_objects_</code>, a generator that yields objects:</p> <pre><code>class MenuScene(BaseScene):\n    def _generate_objects_(self):\n        yield MyPlayer()\n        yield MyButton()\n</code></pre> <p>Lifecycle hooks</p> <p>Override these for scene-specific behavior:</p> <ul> <li><code>on_enter()</code> \u2014 called when scene is entered.</li> <li><code>on_exit()</code> \u2014 called when leaving the scene.</li> <li><code>on_pause()</code> / <code>on_resume()</code> \u2014 called when scene is paused/resumed.</li> </ul> <p>Notes and tips</p> <ul> <li>Scenes respect the global <code>settings.WINDOW_SIZE</code> from your project's settings.</li> <li>Use <code>draw_debug_overlay()</code> to provide a quick on-screen debug readout while developing.</li> </ul>"},{"location":"concepts/","title":"xodex Concepts","text":"<p>This page explains the main ideas used across xodex. Use these as a mental model when designing scenes and objects.</p> <p>Core concepts</p> <ul> <li> <p>Object model: xodex separates responsibilities into three orthogonal roles:</p> </li> <li> <p><code>DrawableObject</code> \u2014 objects that render to a <code>pygame.Surface</code>.</p> </li> <li><code>LogicalObject</code> \u2014 objects that have updatable logic (physics, AI).</li> <li> <p><code>EventfulObject</code> \u2014 objects that respond to Pygame events (input).</p> </li> <li> <p>Scene: a <code>BaseScene</code> composes objects and manages lifecycle, drawing,   updating, and event dispatch. Scenes yield objects via <code>_generate_objects_</code>.</p> </li> <li> <p>ObjectsManager / SceneManager: utilities that register, query, and manage   collections of objects and scenes for an application.</p> </li> <li> <p>Settings: a central <code>settings.py</code> configuration declares window size,   resources, and other project-specific values.</p> </li> </ul> <p>Design tips</p> <ul> <li>Favor small objects with a single responsibility (draw/update/event).</li> <li>Use <code>make_xodex_object</code> to adapt existing classes when migrating code.</li> <li>Keep scene logic (state and transitions) in scenes and object logic inside   objects \u2014 this makes testing and reuse easier.</li> </ul> <p>See the API reference and guides for concrete examples.</p>"},{"location":"getting-started/","title":"Getting started","text":"<p>This section helps you install, configure, and run a basic xodex project.</p>"},{"location":"getting-started/#key-topics","title":"Key topics","text":"<ul> <li>First steps after installation</li> <li>An overview of xodex's features</li> <li>How to get help</li> </ul>"},{"location":"getting-started/#installing-xodex","title":"Installing xodex","text":""},{"location":"getting-started/#versions","title":"Versions","text":""},{"location":"getting-started/#stable-version","title":"Stable Version","text":""},{"location":"getting-started/#old-version","title":"Old Version","text":""},{"location":"getting-started/#installation-methods","title":"Installation methods","text":"<p>Install xodex with package manager of choice.</p>"},{"location":"getting-started/#pypi","title":"PyPI","text":"<p>For convenience, xodex is published to PyPI.</p> <p>If installing from PyPI, we recommend installing xodex into an isolated environment, e.g., with <code>pipx</code>:</p> <pre><code>$ pipx install xodex\n</code></pre> <p>However, <code>pip</code> can also be used:</p> <pre><code>$ pip install xodex\n</code></pre>"},{"location":"getting-started/#docker","title":"Docker","text":""},{"location":"getting-started/#github-releases","title":"GitHub Releases","text":""},{"location":"getting-started/#suggested-next-pages","title":"Suggested next pages","text":"<ul> <li>Quick hands-on: First steps</li> <li>How projects are organized: Working on projects guide</li> <li>Dive into the API: API Reference</li> </ul> <p>Read on, or jump directly to a guide or reference page depending on whether you prefer a tutorial or an API-style lookup.</p>"},{"location":"getting-started/features/","title":"Features","text":""},{"location":"getting-started/features/#projects","title":"Projects","text":"<p>Creating and working on projects, i.e., with a <code>settings.py</code>.</p> <ul> <li><code>xodex init</code>: Create a new xodex project.</li> <li><code>xodex run</code>: Run a command in the project environment.</li> <li><code>xodex build</code>: Build the project into executable.</li> </ul> <p>See the guide on projects to get started.</p>"},{"location":"getting-started/features/#utility","title":"Utility","text":""},{"location":"getting-started/features/#next-steps","title":"Next steps","text":"<p>concept pages for in-depth details about xodex's features, or learn how to get help if you run into any problems.</p>"},{"location":"getting-started/first-steps/","title":"First steps with xodex","text":"<p>After installing xodex, you can check that xodex is available by running the <code>xodex</code> command:</p> <pre><code>$ xodex\nAn extreamely great pygame based python game engine.\n\nUsage: xodex [OPTIONS] &lt;COMMAND&gt;\n\n...\n</code></pre> <p>You should see a help menu listing the available commands.</p>"},{"location":"getting-started/first-steps/#next-steps","title":"Next steps","text":"<p>Now that you've confirmed xodex is installed, check out an overview of features, learn how to get help if you run into any problems.</p>"},{"location":"getting-started/help/","title":"Getting help","text":""},{"location":"getting-started/help/#help-menus","title":"Help menus","text":"<p>The <code>--help</code> flag can be used to view the help menu for a command, e.g., for <code>xodex</code>:</p> <pre><code>$ xodex --help\n</code></pre> <p>To view the help menu for a specific command, e.g., for <code>xodex init</code>:</p> <pre><code>$ xodex init --help\n</code></pre> <p>When using the <code>--help</code> flag, xodex displays a condensed help menu. To view a longer help menu for a command, use <code>xodex help</code>:</p> <pre><code>$ xodex help\n</code></pre> <p>To view the long help menu for a specific command, e.g., for <code>xodex init</code>:</p> <pre><code>$ xodex help init\n</code></pre> <p>When using the long help menu, xodex will attempt to use <code>less</code> or <code>more</code> to \"page\" the output so it is not all displayed at once. To exit the pager, press <code>q</code>.</p>"},{"location":"getting-started/help/#displaying-verbose-output","title":"Displaying verbose output","text":"<p>The <code>-v</code> flag can be used to display verbose output for a command, e.g., for <code>xodex build</code>:</p> <pre><code>$ xodex build -v\n</code></pre> <p>The <code>-v</code> flag can be repeated to increase verbosity, e.g.:</p> <pre><code>$ xodex build -vv\n</code></pre> <p>Often, the verbose output will include additional information about why xodex is behaving in a certain way.</p>"},{"location":"getting-started/help/#viewing-the-version","title":"Viewing the version","text":"<p>When seeking help, it's important to determine the version of xodex that you're using \u2014 sometimes the problem is already solved in a newer version.</p> <p>To check the installed version:</p> <pre><code>$ xodex version\n</code></pre> <p>The following are also valid:</p> <pre><code>$ xodex --version      # Same output as `xodex version`\n$ xodex -V             # Will not include the build commit and date\n</code></pre> <p>Note</p> <p>use <code>xodex --version</code> instead of <code>xodex version</code>.</p>"},{"location":"getting-started/help/#open-an-issue-on-github","title":"Open an issue on GitHub","text":"<p>The issue tracker on GitHub is a good place to report bugs and request features. Make sure to search for similar issues first, as it is common for someone else to encounter the same problem.</p>"},{"location":"reference/","title":"Reference","text":"<p>The reference section provides information about specific parts of xodex:</p> <ul> <li>Commands: A reference for xodex's command line interface.</li> <li>Settings: A reference for xodex project's configuration schema.</li> <li>Policies: xodex's versioning policy, platform support policy, and license.</li> </ul> <p>Looking for a broader overview? Check out the concepts documentation.</p>"},{"location":"reference/cli/","title":"CLI Reference","text":""},{"location":"reference/cli/#xodex-cli","title":"xodex CLI","text":"<p>xodex is a small management CLI that helps you run, build, and manage xodex projects. Use the <code>xodex</code> command from a project directory to run commands from the project's <code>project/management/commands</code> or the bundled commands.</p> <p>Usage</p> <pre><code>xodex [OPTIONS] &lt;COMMAND&gt; [ARGS]\n</code></pre> <p>Common commands (project may add more):</p> <ul> <li><code>xodex run</code> \u2014 Run the current project.</li> <li><code>xodex init &lt;name&gt;</code> \u2014 Create a new xodex project scaffold.</li> <li><code>xodex shell</code> \u2014 Open an interactive shell with the project's objects loaded.</li> <li><code>xodex build</code> \u2014 Build the project into a distributable/executable.</li> <li><code>xodex version</code> \u2014 Print the xodex version.</li> <li><code>xodex help &lt;command&gt;</code> \u2014 Show help for a specific command.</li> </ul> <p>See the usage guide for examples and workflows: Usage</p>"},{"location":"reference/cli/#xodex-shell","title":"xodex shell","text":"<p><code>xodex shell</code> opens a developer REPL. Available subcommands vary by project, an example:</p> <pre><code>xodex shell object    # expose registered objects into the shell\n</code></pre> <p>The CLI uses <code>BaseCommand</code> implementations (see <code>xodex.core.management.command.BaseCommand</code>) for argument parsing. Custom commands should subclass <code>BaseCommand</code> and implement <code>add_arguments()</code> and <code>handle()</code>.</p>"},{"location":"reference/environment/","title":"Environment variables","text":"<p>xodex defines and respects the following environment variables:</p>"},{"location":"reference/environment/#xodex_project_name","title":"<code>XODEX_PROJECT_NAME</code>","text":""},{"location":"reference/environment/#xodex_settings_file","title":"<code>XODEX_SETTINGS_FILE</code>","text":""},{"location":"reference/settings/","title":"Project Settings Reference","text":"<p>This page documents the most commonly used settings available in a xodex project's <code>settings.py</code>.</p> <p>Common settings</p> <ul> <li><code>FPS</code> (int): Target frames per second. Default: 60</li> <li><code>WIDTH</code>, <code>HEIGHT</code> (int): Window width and height in pixels.</li> <li><code>WINDOW_SIZE</code> (tuple): <code>(WIDTH, HEIGHT)</code> convenience tuple.</li> <li><code>TITLE</code> (str): Window title.</li> <li><code>VERSION</code> (str): Project version string.</li> <li><code>FULLSCREEN</code> (bool): Whether to start in fullscreen mode.</li> <li><code>ICON_PATH</code> (str|None): Path to the window icon image.</li> <li><code>ASSETS</code> (dict): Optional mapping for named asset paths (images, sounds).</li> </ul> <p>Example</p> <pre><code>FPS = 60\nWIDTH = 720\nHEIGHT = 560\nWINDOW_SIZE = (WIDTH, HEIGHT)\nTITLE = \"My Xodex Game\"\nVERSION = \"0.1.0\"\nFULLSCREEN = False\nICON_PATH = \"assets/icon.png\"\nASSETS = {\n    'player': 'assets/player.png',\n    'bg': 'assets/bg.png',\n}\n</code></pre> <p>Notes</p> <ul> <li>Settings are imported into scenes via <code>from xodex.conf import settings</code>.</li> <li>You can provide a <code>XODEX_SETTINGS_MODULE</code> environment variable to point to   a different settings module for testing or CI.</li> </ul> <p>See also: Working on projects for how the settings fit into a scaffolded project.</p>"},{"location":"reference/policies/","title":"Policies","text":"<ul> <li>Versioning</li> <li>Platform support</li> <li>License</li> </ul>"},{"location":"reference/policies/license/","title":"License","text":"<p>xodex is licensed under</p>"},{"location":"reference/policies/license/#mit-license","title":"MIT License","text":"<p>LICENSE-MIT https://opensource.org/licenses/MIT</p> <p>or at your option.</p> <p>Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in xodex by you, as defined in the MIT license, shall be dually licensed as above, without any additional terms or conditions.</p>"},{"location":"reference/policies/platforms/","title":"Platform support","text":"<p>xodex has support for the following platforms:</p> <ul> <li>macOS</li> <li>Linux</li> <li>Windows</li> </ul> <p>xodex is continuously built, tested, and developed against its basic platforms.</p> <p>xodex ships pre-built wheels to PyPI for its basic platforms.</p>"},{"location":"reference/policies/platforms/#pygame-support","title":"Pygame support","text":"<p>xodex supports and is tested against the following Python versions:</p> <ul> <li>2.6.1</li> </ul>"},{"location":"reference/policies/platforms/#python-support","title":"Python support","text":"<p>xodex supports and is tested against the following Python versions:</p> <ul> <li>3.10</li> <li>3.11</li> <li>3.12</li> <li>3.13</li> <li>3.14</li> </ul> <p>xodex has support for the following Python implementations:</p> <ul> <li>CPython</li> </ul> <p>As with platforms, Support can be thought of \"guaranteed to work\". xodex \"should work\" with these implementations, but stability may vary.</p>"},{"location":"reference/policies/versioning/","title":"Versioning","text":"<p>xodex uses a custom versioning scheme in which the minor version number is bumped for breaking changes, and the patch version number is bumped for bug fixes, enhancements, and other non-breaking changes.</p> <p>xodex is widely used in production. However, we value the ability to iterate on new features quickly and gather changes that could be breaking into clearly marked releases.</p> <p>Once xodex v1.0.0 is released, the versioning scheme will adhere to Semantic Versioning. There is not a particular goal that must be achieved for xodex to reach this milestone.</p> <p>xodex's changelog can be viewed on GitHub.</p>"},{"location":"reference/policies/versioning/#realese-version","title":"Realese version","text":""},{"location":"tutorials/","title":"Getting Started","text":""},{"location":"tutorials/#scenes","title":"Scenes","text":"<ul> <li>Scene</li> <li>BaseScene</li> <li>BlurScene</li> <li>BlurScene</li> <li>BoxBlurScene</li> <li>MotionBlurScene</li> <li>MaskedBlurScene</li> <li>GaussianBlurScene</li> </ul>"},{"location":"tutorials/#objects","title":"Objects","text":"<ul> <li>Image</li> <li>Animator</li> <li>SpriteSheet</li> </ul>"},{"location":"tutorials/#flappy","title":"Flappy","text":""},{"location":"tutorials/#tutorial-overview","title":"Tutorial overview","text":"<p>Check out one of the core guides to get started:</p> <ul> <li>Creating and working on projects</li> </ul> <p>Or, explore the concept documentation for comprehensive breakdown of each feature.</p>"},{"location":"tutorials/#guides","title":"Guides","text":"<p>Practical guides for working with xodex projects and common workflows.</p> <ul> <li>Working on project</li> <li>Flappy Bird Demo </li> </ul> <p>Choose a guide to get started with a real-world workflow.</p>"},{"location":"tutorials/flappy/","title":"Flappy Bird tutorial (improved)","text":"<p>This tutorial shows how to build a minimal Flappy Bird clone using the xodex engine. It expands the existing step-by-step guide with clearer contracts, complete code sketches (based on the reference flappy clone), common edge cases, and practical \"how to run\" instructions.</p> <p>Target audience: developers comfortable with Python and basic game loops.</p> <p>What you'll get from this tutorial</p> <ul> <li>A small contract describing the objects and their responsibilities.</li> <li>Complete, corrected examples for the bird, pipes, scoring and scenes.</li> <li>Notes about edge cases and testing.</li> <li>Quick steps to create a runnable project skeleton using the xodex template.</li> </ul> <p>Quick contract (inputs/outputs)</p> <ul> <li>Inputs: keyboard (space/up) or mouse/touch for flap; window size from   settings.</li> <li>Outputs: rendered game frame, sounds (wing/point/hit), score integer.</li> <li>Data shapes: objects expose methods perform_update(deltatime), perform_draw(surface),   handle_event(event) and a <code>rect</code> (pygame.Rect) for collision.</li> </ul> <p>Edge cases to consider</p> <ul> <li>Running at variable FPS: use delta-time in physics calculations.</li> <li>Window resize: choose fixed game coordinate system (WIDTH/HEIGHT in   settings) or scale contents explicitly.</li> <li>Audio unavailable: guard sound playback so missing files don't crash.</li> <li>Asset paths: prefer project-relative paths and provide helpful error messages.</li> </ul> <p>Checklist (what we'll cover)</p> <ol> <li>Project scaffold and settings</li> <li>Implement objects: Background, Floor, Pipe, Pipes manager, Bird/Flappy, Score</li> <li>Implement scenes: MainScene (menu), GameScene (play), OverScene (game over)</li> <li>Collision detection, scoring and sound hooks</li> <li>Run instructions and optional testing notes</li> </ol> <p>Minimal project scaffold</p> <p>Scaffold a new project from the xodex template (recommended):</p> <ol> <li> <p>Create a folder and use the xodex template shipped with this repo:</p> </li> <li> <p>Copy the <code>xodex/template/project/</code> directory into a new folder <code>flappy/</code>.</p> </li> <li>Edit <code>flappy/settings.py</code> and <code>flappy/objects.py</code> per the examples below.</li> </ol> <p>Should get you will typically see:</p> <pre><code>.\n\u251c\u2500\u2500 flappy\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __main__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 settings.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 objects\n\u2502\u00a0\u00a0 \u2502   \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u2502   \u251c\u2500\u2500 score.py\n\u2502\u00a0\u00a0 \u2502   \u251c\u2500\u2500 flappy.py\n\u2502\u00a0\u00a0 \u2502   \u2514\u2500\u2500 background.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 scenes\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 mainscene.py\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 gamescene.py\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 overscene.py\n\u251c\u2500\u2500 Assets\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 sounds\n\u2502\u00a0\u00a0 \u2502   \u251c\u2500\u2500 die.wav\n\u2502\u00a0\u00a0 \u2502   \u251c\u2500\u2500 hit.wav\n\u2502\u00a0\u00a0 \u2502   \u251c\u2500\u2500 wing.wav\n\u2502\u00a0\u00a0 \u2502   \u251c\u2500\u2500 point.wav\n\u2502\u00a0\u00a0 \u2502   \u2514\u2500\u2500 swoosh.wav\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 images\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 0.png\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 1.png\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 2.png\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 3.png\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 4.png\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 5.png\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 6.png\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 7.png\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 8.png\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 9.png\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 base.png\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 message.png\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 gameover.png\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 pipe-red.png\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 pipe-green.png\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 background-day.png\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 background-night.png\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 redbird-downflap.png\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 redbird-midflap.png\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 redbird-upflap.png\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 bluebird-downflap.png\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 bluebird-midflap.png\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 bluebird-upflap.png\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 yellowbird-downflap.png\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 yellowbird-midflap.png\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 yellowbird-upflap.png\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 overscene.py\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 manage.py\n\u2514\u2500\u2500 requirements.txt\n</code></pre> <ol> <li>A minimal <code>settings.py</code> useful for the tutorial:</li> </ol> <pre><code># --- Window &amp; Display ---\nFPS = 30\nWIDTH = 288\nHEIGHT = 512\nWINDOW_SIZE = (WIDTH, HEIGHT)\nTITLE = \"Flappy - xodex tutorial\"\nMAIN_SCENE = \"MainScene\"\n</code></pre> <p>Run tips</p> <ul> <li>Install dependencies from the provided <code>requirements.txt</code> (pygame, xodex   dependencies).</li> <li>Start the game with your project <code>manage.py</code> or the CLI command from the   template (for a scaffolded project this is <code>xodex run</code> or <code>python -m flappy</code>).</li> </ul> <p>If you'd like, I can now:</p> <ul> <li>Update the three tutorial pages in <code>docs/tutorials/flappy/</code> with full   corrected examples and clearer explanations (objects.md, scenes.md and this   index). (recommended)</li> <li>Or generate a runnable <code>project/</code> sample using the xodex template with   complete source and lightweight placeholder assets.</li> </ul> <p>Which should I do next? (I'll proceed to update the docs if you don't say otherwise.)</p>"},{"location":"tutorials/flappy/objects/","title":"Flappy Bird Objects","text":""},{"location":"tutorials/flappy/objects/#background","title":"Background","text":"<pre><code>class Background(Image):\n    \"\"\"Game Background\"\"\"\n\n    def __init__(self):\n        backgrounds = [\n            \"assets/images/background-day.png\",\n            \"assets/images/background-night.png\",\n        ]\n        super().__init__(random.choice(backgrounds), (0, 0))\n</code></pre>"},{"location":"tutorials/flappy/objects/#floor","title":"Floor","text":"<pre><code>class Floor(Image):\n    \"\"\"Game Fooor\"\"\"\n\n    def __init__(self, win_width):\n        super().__init__(\"assets/images/base.png\", pos=(0, int(512 * 0.79)))\n        self.vel_x = 4\n        self.x_extra = self.rect.width - win_width\n\n    def perform_draw(self, surface, *args, **kwargs):\n        self.rect.x = -((-self.rect.x + self.vel_x) % self.x_extra)\n        return super().perform_draw(surface, *args, **kwargs)\n</code></pre>"},{"location":"tutorials/flappy/objects/#pipe","title":"Pipe","text":"<pre><code>class Pipe(Image):\n    def __init__(\n        self, win_width, win_height, x, y, flipped: bool = False, vel_x: int = -4\n    ):\n        self.flipped = flipped\n        self.vel_x = vel_x\n        image_path = random.choice(\n            [\"assets/images/pipe-green.png\", \"assets/images/pipe-red.png\"]\n        )\n        super().__init__(image_path, pos=(x, y))\n        if flipped:\n            self.flip(False, True)\n\n    def perform_update(self, deltatime, *args, **kwargs):\n        self.rect.x += self.vel_x\n\n    def is_off_screen(self):\n        return self.rect.right &lt; 0\n</code></pre>"},{"location":"tutorials/flappy/objects/#pipes","title":"Pipes","text":"<pre><code>class Pipes(DrawableObject, EventfulObject, LogicalObject):\n    def __init__(\n        self, win_width, win_height, gap_size=100, pipe_distance=200, vel_x=-4\n    ):\n        self.win_width = win_width\n        self.win_height = win_height\n        self.gap_size = gap_size\n        self.pipe_distance = pipe_distance\n        self.vel_x = vel_x\n        self.upper = []\n        self.lower = []\n        self._spawn_pipe()\n\n    def _spawn_pipe(self):\n        # Randomize the gap position\n        min_y = int(self.win_height * 0.2)\n        max_y = int(self.win_height * 0.6)\n        gap_y = random.randint(min_y, max_y)\n        pipe_x = self.win_width + 10\n        upper_pipe = Pipe(\n            self.win_width,\n            self.win_height,\n            pipe_x,\n            gap_y - self.gap_size // 2 - 320,\n            True,\n            self.vel_x,\n        )\n        lower_pipe = Pipe(\n            self.win_width,\n            self.win_height,\n            pipe_x,\n            gap_y + self.gap_size // 2,\n            False,\n            self.vel_x,\n        )\n        self.upper.append(upper_pipe)\n        self.lower.append(lower_pipe)\n\n    def perform_update(self, deltatime, *args, **kwargs):\n        for pipe in self.upper + self.lower:\n            pipe.perform_update(deltatime, *args, **kwargs)\n        # Remove pipes that are off screen\n        self.upper = [p for p in self.upper if not p.is_off_screen()]\n        self.lower = [p for p in self.lower if not p.is_off_screen()]\n        # Spawn new pipes if needed\n        if len(self.upper) == 0 or (\n            self.upper[-1].rect.x &lt; self.win_width - self.pipe_distance\n        ):\n            self._spawn_pipe()\n\n    def perform_draw(self, surface, *args, **kwargs):\n        for pipe in self.upper + self.lower:\n            pipe.perform_draw(surface, *args, **kwargs)\n\n    def handle_event(self, event, *args, **kwargs):\n        for pipe in self.upper + self.lower:\n            pipe.handle_event(event, *args, **kwargs)\n</code></pre>"},{"location":"tutorials/flappy/objects/#4-bird-object-drawable-logical-eventful","title":"4 \u2014 Bird object (Drawable + Logical + Eventful)","text":"<p>Create a <code>Bird</code> by combining responsibilities. Implement draw, update and event handling (jump on key press):</p> <pre><code>class Bird(Animator):\n    \"\"\"\n    Bird class handles the animated sprite for the player character.\n\n    Args:\n        x (int): Initial x position.\n        y (int): Initial y position.\n    \"\"\"\n\n    def __init__(self, x=50, y=256):\n        bird_sprites = [\n            [\n                \"assets/images/bluebird-downflap.png\",\n                \"assets/images/bluebird-midflap.png\",\n                \"assets/images/bluebird-upflap.png\",\n            ],\n            [\n                \"assets/images/yellowbird-downflap.png\",\n                \"assets/images/yellowbird-midflap.png\",\n                \"assets/images/yellowbird-upflap.png\",\n            ],\n            [\n                \"assets/images/redbird-downflap.png\",\n                \"assets/images/redbird-midflap.png\",\n                \"assets/images/redbird-upflap.png\",\n            ],\n        ]\n        super().__init__(\n            random.choice(bird_sprites),\n            frame_duration=100,\n            loop=True,\n            pingpong=False,\n            reverse=False,\n            on_finish=None,\n            pos=(x, y),\n        )\n</code></pre> <pre><code>class Flappy(DrawableObject, EventfulObject, LogicalObject):\n    \"\"\"\n    Flappy is the main player character, handling movement, flapping, and collision.\n\n    Args:\n        x (int): Initial x position.\n        y (int): Initial y position.\n        floor: Floor object for collision.\n        pipes: List of pipe objects for collision.\n    \"\"\"\n\n    def __init__(self, win_width, win_height):\n        x = int(win_width * 0.2)\n        y = int((win_height - 24) / 2)\n        self.flappy = Bird(x, y)\n\n        self.min_y = -2 * self.flappy.rect.height\n        self.max_y = (win_height * 0.79) - self.flappy.rect.height * 0.75\n\n        self.crash_entity = None\n        self.crashed = False\n        self.set_mode(PlayerMode.SHM)\n\n    def set_mode(self, mode: PlayerMode) -&gt; None:\n        \"\"\"\n        Set the current movement mode for Flappy.\n\n        Args:\n            mode (PlayerMode): The mode to set.\n        \"\"\"\n        self.mode = mode\n        if mode == PlayerMode.NORMAL:\n            self.reset_vals_normal()\n            Sounds().play(\"wing\")\n        elif mode == PlayerMode.SHM:\n            self.reset_vals_shm()\n        elif mode == PlayerMode.CRASH:\n            Sounds().play(\"hit\")\n            if self.crash_entity == \"pipe\":\n                Sounds().play(\"die\")\n            self.reset_vals_crash()\n\n    def reset_vals_crash(self) -&gt; None:\n        self.acc_y = 2\n        self.vel_y = 7\n        self.max_vel_y = 15\n        self.vel_rot = -8\n\n    def reset_vals_normal(self) -&gt; None:\n        \"\"\"Reset physics values for normal gameplay.\"\"\"\n        self.vel_y = -9\n        self.max_vel_y = 10\n        self.min_vel_y = -8\n        self.acc_y = 1\n        self.rot = 80\n        self.vel_rot = -3\n        self.rot_min = -90\n        self.rot_max = 20\n        self.flap_acc = -9\n        self.flapped = False\n\n    def reset_vals_shm(self) -&gt; None:\n        \"\"\"Reset physics values for simple harmonic motion (idle).\"\"\"\n        self.vel_y = 1\n        self.max_vel_y = 4\n        self.min_vel_y = -4\n        self.acc_y = 0.5\n\n        self.rot = 0\n        self.vel_rot = 0\n        self.rot_min = 0\n        self.rot_max = 0\n\n        self.flap_acc = 0\n        self.flapped = False\n\n    def flap(self) -&gt; None:\n        \"\"\"\n        Make the bird flap if possible.\n        Only works if not in CRASH mode and not at the top of the screen.\n        \"\"\"\n        if self.mode == PlayerMode.CRASH:\n            return\n        if self.flappy.rect.y &gt; self.min_y:\n            self.vel_y = self.flap_acc\n            self.flapped = True\n            # Instantly rotate up on flap\n            self.rot = self.rot_max\n            Sounds().play(\"wing\")\n\n    def tick_normal(self) -&gt; None:\n        \"\"\"Update position and rotation for normal gameplay mode.\"\"\"\n        if self.vel_y &lt; self.max_vel_y and not self.flapped:\n            self.vel_y += self.acc_y\n        if self.flapped:\n            self.flapped = False\n\n        self.flappy.rect.y = clamp(\n            self.flappy.rect.y + self.vel_y, self.min_y, self.max_y\n        )\n\n        # Rotate up on flap, then smoothly rotate down as falling\n        if self.vel_y &lt; 0:\n            self.rot = self.rot_max\n        else:\n            self.rotate()\n\n    def rotate(self) -&gt; None:\n        \"\"\"Rotate smoothly\"\"\"\n        self.rot += self.vel_rot\n        if self.rot &lt; self.rot_min:\n            self.rot = self.rot_min\n        elif self.rot &gt; self.rot_max:\n            self.rot = self.rot_max\n\n    def tick_crash(self) -&gt; None:\n        \"\"\"Update position and rotation for crash mode.\"\"\"\n        if self.min_y &lt;= self.flappy.rect.y &lt;= self.max_y:\n            self.flappy.rect.y = clamp(\n                self.flappy.rect.y + self.vel_y, self.min_y, self.max_y\n            )\n            # Rotate only when it's a pipe crash and bird is still falling\n            if self.crash_entity != \"floor\":\n                self.rotate()\n\n        # player velocity change\n        if self.vel_y &lt; self.max_vel_y:\n            self.vel_y += self.acc_y\n\n    def tick_shm(self) -&gt; None:\n        \"\"\"Update position for idle (SHM) mode.\"\"\"\n        if self.vel_y &gt;= self.max_vel_y or self.vel_y &lt;= self.min_vel_y:\n            self.acc_y *= -1\n        self.vel_y += self.acc_y\n        self.flappy.rect.y += self.vel_y\n\n    def collided(self, floor, pipes) -&gt; bool:\n        \"\"\"\n        Check for collision with the floor or pipes.\n\n        Returns:\n            bool: True if collision detected, else False.\n        \"\"\"\n\n        # Floor collision\n        if self.collide(floor.rect):\n            self.crashed = True\n            self.crash_entity = \"floor\"\n            return True\n\n        # Pipes collision\n        for pipe in pipes.upper:\n            if self.collide(pipe.rect):\n                self.crashed = True\n                self.crash_entity = \"pipe\"\n                return True\n\n        for pipe in pipes.lower:\n            if self.collide(pipe.rect):\n                self.crashed = True\n                self.crash_entity = \"pipe\"\n                return True\n\n        return False\n\n    def collide(self, other) -&gt; bool:\n        \"\"\"collide\"\"\"\n        return self.flappy.rect.colliderect(other)\n\n    def crossed(self, pipe) -&gt; bool:\n        \"\"\"Return True if Flappy has just crossed a pipe (for scoring).\"\"\"\n        # Check if Flappy's x just passed the pipe's x (from right to left)\n        return (\n            pipe.rect.right &lt; self.flappy.rect.left\n            and pipe.rect.right &gt;= self.flappy.rect.left + pipe.vel_x\n        )\n\n    def perform_draw(self, surface, *args, **kwargs):\n        \"\"\"\n        Draw Flappy on the given surface.\n\n        Args:\n            surface: Pygame surface.\n        \"\"\"\n\n        image = self.flappy.get_image()\n        rotated_image = pygame.transform.rotate(image.image, self.rot)\n        rotated_rect = rotated_image.get_rect(center=self.flappy.rect.center)\n        surface.blit(rotated_image, rotated_rect)\n\n    def handle_event(self, event: Event, *args, **kwargs) -&gt; None:\n        \"\"\"\n        Handle an event for Flappy.\n\n        Args:\n            event (pygame.event.Event): The event to handle.\n        \"\"\"\n        self.flappy.handle_event(event, *args, **kwargs)\n\n    def perform_update(self, deltatime: float, *args, **kwargs) -&gt; None:\n        \"\"\"\n        Update Flappy's state.\n\n        Args:\n            deltatime (float): Time since last update in seconds.\n        \"\"\"\n\n        if self.mode == PlayerMode.SHM:\n            self.tick_shm()\n        elif self.mode == PlayerMode.NORMAL:\n            self.tick_normal()\n        elif self.mode == PlayerMode.CRASH:\n            self.tick_crash()\n\n        self.flappy.perform_update(deltatime, *args, **kwargs)\n</code></pre> <pre><code>class Score(DrawableObject):\n    \"\"\"Game Score\n\n    Simple score display that composes digit `Image` objects and plays a\n    sound when the player earns a point.\n    \"\"\"\n\n    def __init__(self, win_width, win_height):\n        # load digit images 0-9\n        self.numbers = [Image(f\"assets/images/{i}.png\") for i in range(10)]\n\n        self.width = win_width\n        self.height = win_height\n\n        self.y = int(win_height * 0.1)\n        self.score = 0\n\n    def set(self, score: int) -&gt; None:\n        \"\"\"Set Score\"\"\"\n        self.score = score\n\n    def reset(self) -&gt; None:\n        \"\"\"Reset Score\"\"\"\n        self.score = 0\n\n    def add(self) -&gt; None:\n        \"\"\"Increase Score\"\"\"\n        self.score += 1\n        # Use the engine sound helper; guard if sound is missing\n        try:\n            Sounds().play(\"point\")\n        except Exception:\n            # don't crash the game for missing/misconfigured audio\n            pass\n\n    def perform_draw(self, surface: pygame.Surface, *args, **kwargs) -&gt; None:\n        \"\"\"Draw the score centered at the top of the screen.\"\"\"\n        score_digits: list[int] = [int(x) for x in list(str(self.score))]\n        images: list[Image] = [self.numbers[digit] for digit in score_digits]\n        digits_width = sum(image.rect.width for image in images)\n        x_offset = (self.width - digits_width) // 2\n\n        for image in images:\n            surface.blit(image.image, (x_offset, self.y))\n            x_offset += image.rect.width\n\n    @property\n    def rect(self) -&gt; pygame.Rect:\n        \"\"\"Bounding rect for layout/collision (useful for scene positioning).\"\"\"\n        score_digits: list[int] = [int(x) for x in list(str(self.score))]\n        images: list[Image] = [self.numbers[digit] for digit in score_digits]\n        w = sum(image.rect.width for image in images)\n        x = (self.width - w) // 2\n        h = max(image.rect.height for image in images)\n        return pygame.Rect(x, self.y, w, h)\n</code></pre>"},{"location":"tutorials/flappy/objects/#5-pipes-and-collision","title":"5 \u2014 Pipes and collision","text":"<p>Implement a simple <code>PipeManager</code> that yields pipe pairs, moves them left, and checks collision with the <code>Bird</code>. On collision, call scene's <code>pause()</code> or transition to a Game Over scene.</p> <p>Notes and tips</p> <ul> <li>Physics: the example above mostly uses discrete integer velocities (matching   the original Flappy feel). If your engine uses variable FPS, multiply   accelerations and position changes by <code>deltatime</code> (seconds) for stable   physics.</li> <li>Collision: use <code>pygame.Rect</code>'s <code>colliderect</code> for simple AABB collisions.   If you need pixel-perfect collision, consider masks but only if necessary.</li> <li>Sound: wrap calls to <code>Sounds().play()</code> in a try/except when running in   headless or CI environments to avoid crashes caused by missing audio drivers.</li> </ul> <pre><code>\n</code></pre>"},{"location":"tutorials/flappy/objects/#6-scoring-and-polish","title":"6 \u2014 Scoring and polish","text":"<pre><code>class Score(DrawableObject):\n    \"\"\"Game Score\"\"\"\n\n    def __init__(self, win_width, win_height):\n        self.numbers = [\n            Image(\"assets/images/0.png\"),\n            Image(\"assets/images/1.png\"),\n            Image(\"assets/images/2.png\"),\n            Image(\"assets/images/3.png\"),\n            Image(\"assets/images/4.png\"),\n            Image(\"assets/images/5.png\"),\n            Image(\"assets/images/6.png\"),\n            Image(\"assets/images/7.png\"),\n            Image(\"assets/images/8.png\"),\n            Image(\"assets/images/9.png\"),\n        ]\n\n        self.width = win_width\n        self.height = win_height\n\n        self.y = win_height * 0.1\n        self.score = 0\n\n    def set(self, score: int) -&gt; None:\n        \"\"\"Set Score\"\"\"\n        self.score = score\n\n    def reset(self) -&gt; None:\n        \"\"\"Reset Score\"\"\"\n        self.score = 0\n\n    def add(self) -&gt; None:\n        \"\"\"Increase Score\"\"\"\n        self.score += 1\n        pygame.mixer.Sound(\"assets/sounds/point.wav\").play()\n\n    def perform_draw(self, surface: pygame.Surface, *args, **kwargs) -&gt; None:\n        \"\"\"\n        Actual drawing logic. Must be implemented by subclass.\n\n        Args:\n            surface (Surface): The Pygame surface to draw on.\n            *args: Additional positional arguments.\n            **kwargs: Additional keyword arguments.\n        \"\"\"\n        score_digits: list[int] = [int(x) for x in list(str(self.score))]\n        images: list[Image] = [self.numbers[digit] for digit in score_digits]\n        digits_width = sum(image.rect.width for image in images)\n        x_offset = (self.width - digits_width) / 2\n\n        for image in images:\n            surface.blit(image.image, (x_offset, self.y))\n            x_offset += image.rect.width\n\n    @property\n    def rect(self) -&gt; pygame.Rect:\n        \"\"\"rect\"\"\"\n        score_digits: list[int] = [int(x) for x in list(str(self.score))]\n        images: list[Image] = [self.numbers[digit] for digit in score_digits]\n        w = sum(image.rect.width for image in images)\n        x = (self.width - w) / 2\n        h = max(image.rect.height for image in images)\n        return pygame.Rect(x, self.y, w, h)\n</code></pre> <ul> <li>Count pipes passed for score.</li> <li>Add sound effects using <code>xodex.game.sounds.Sounds</code>.</li> <li>Use <code>Scene.export_image()</code> to create screenshots for debugging.</li> </ul>"},{"location":"tutorials/flappy/scenes/","title":"Flappy Bird Scenes","text":""},{"location":"tutorials/flappy/scenes/#game-home-scene","title":"Game Home Scene","text":"<pre><code>class MainScene(Scene):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n    def _generate_objects_(self):\n        Bird = self.object.Bird\n        Image = self.object.Image\n        Floor = self.object.Floor\n        Flappy = self.object.Flappy\n        Background = self.object.Background\n\n        message = Image(\n            \"assets/images/message.png\",\n            (int((self.width - 184) // 2), int(self.height * 0.12)),\n        )\n\n        yield Background()\n        yield Floor(self.width)\n        yield Bird(120, 120)\n        yield Flappy(self.width, self.height)\n        yield message\n\n    def handle_scene(self, event: Event, *args, **kwargs) -&gt; None:\n        \"\"\"\n        Handle an event for all objects in the scene.\n\n        Args:\n            event (pygame.event.Event): The event to handle.\n        \"\"\"\n        if event.type == pygame.MOUSEBUTTONDOWN:\n            self.entergame()\n        super().handle_scene(event, *args, **kwargs)\n\n    def entergame(self):\n        \"\"\"entergame\"\"\"\n        # self.sounds.play(\"wing\")\n        self.manager.reset(\"GameScene\")\n\n    # Notes:\n    # - `_generate_objects_` is called by the Scene manager when the scene is\n    #   created or reset. Use it to yield live instances of objects that the\n    #    scene should manage.\n    # - To preload sounds or resources, use `on_first_enter` or `on_enter` if\n    #   your scene system supports those hooks.\n</code></pre>"},{"location":"tutorials/flappy/scenes/#game-play-scene","title":"Game Play Scene","text":"<pre><code>class GameScene(Scene):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n        Pipes = self.object.Pipes\n        Floor = self.object.Floor\n        Score = self.object.Score\n        Flappy = self.object.Flappy\n\n        self.floor = Floor(self.width)\n        self.score = Score(self.width, self.height)\n        self.pipes = Pipes(self.width, self.height)\n        self.flappy = Flappy(self.width, self.height)\n\n    def _generate_objects_(self):\n        Background = self.object.Background\n\n        self.flappy.set_mode(2)  # normal mode\n\n        yield Background()\n        yield self.floor\n        yield self.pipes\n        yield self.score\n        yield self.flappy\n\n    def gameover(self):\n        \"\"\"entergame\"\"\"\n        # self.sounds.play(\"die\")\n        self.manager.append(\"OverScene\", self.screen, self.score.score)\n\n    def is_tap_event(self, event) -&gt; bool:\n        \"\"\"\n        Determine if the event is a flap/tap event.\n\n        Args:\n            event: Pygame event.\n\n        Returns:\n            bool: True if event is a tap/flap.\n        \"\"\"\n        m_left, _, _ = pygame.mouse.get_pressed()\n        space_or_up = event.type == pygame.KEYDOWN and (\n            event.key == pygame.K_SPACE or event.key == pygame.K_UP\n        )\n        screen_tap = event.type == pygame.FINGERDOWN\n        return m_left or space_or_up or screen_tap\n\n    def handle_scene(self, event: Event, *args, **kwargs) -&gt; None:\n        \"\"\"\n        Handle an event for all objects in the scene.\n\n        Args:\n            event (pygame.event.Event): The event to handle.\n        \"\"\"\n        if self.is_tap_event(event):\n            self.flappy.flap()\n        super().handle_scene(event, *args, **kwargs)\n\n    def update_scene(self, deltatime: float, *args, **kwargs) -&gt; None:\n        \"\"\"\n        Update all objects in the scene, unless paused.\n\n        Args:\n            deltatime (float): Time since last update (ms).\n        \"\"\"\n\n        # Collision check first: when collided, transition to game over.\n        if self.flappy.collided(self.floor, self.pipes):\n            # play sounds safely\n            try:\n                self.sounds.play(\"hit\")\n            except Exception:\n                pass\n            self.gameover()\n\n        # Score: when flappy crosses a pipe, increment score. Use a copy of\n        # the pipe list so modifications during iteration are safe.\n        for pipe in list(self.pipes.upper):\n            if self.flappy.crossed(pipe):\n                self.score.add()\n\n        # Continue with default update to tick and draw children\n        super().update_scene(deltatime, *args, **kwargs)\n</code></pre>"},{"location":"tutorials/flappy/scenes/#game-over-scene","title":"Game Over Scene","text":"<pre><code>class OverScene(BlurScene):\n    def __init__(self, blur_surface, score, **kwargs):\n        super().__init__(\n            blur_surface, blur_count=2, blur_duration=3, on_blur_complete=None, **kwargs\n        )\n        self.score = score\n\n    def _generate_objects_(self):\n        Image = self.object.Image\n        Score = self.object.Score\n\n        score = Score(self.width, self.height)\n        score.set(self.score)\n\n        message = Image(\n            \"assets/images/gameover.png\",\n            (int((self.width - 184) // 2), int(self.height * 0.5)),\n        )\n\n        yield message\n        yield score\n\n    def handle_scene(self, event: Event, *args, **kwargs) -&gt; None:\n        \"\"\"\n        Handle an event for all objects in the scene.\n\n        Args:\n            event (pygame.event.Event): The event to handle.\n        \"\"\"\n        if event.type == pygame.MOUSEBUTTONDOWN:\n            self.gotomain()\n        super().handle_scene(event, *args, **kwargs)\n\n    def gotomain(self):\n        \"\"\"gotomain\"\"\"\n        # self.sounds.play(\"wing\")\n        self.manager.reset(\"MainScene\")\n\n    def on_first_enter(self, *args, **kwargs):\n        # self.sounds.play(\"swoosh\")\n        pass\n\n# Scene lifecycle &amp; tips\n- Scene creation: `_generate_objects_` should yield new instances when the\n# scene is first created. Keep scene state (like score) on the scene instance\n# if it needs to persist between resets.\n- Event handling: call `super().handle_scene()` to ensure child objects\n# receive events. Use `is_tap_event` to centralize input mapping (mouse, key,\n# touch).\n- Audio: use the engine `Sounds()` helper and guard in case audio fails in\n# headless environments.\n</code></pre>"}]}